[
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "COUNT",
        "kind": 5,
        "importPath": "def.Assignment 1.Fibbo-iterative",
        "description": "def.Assignment 1.Fibbo-iterative",
        "peekOfCode": "COUNT = 0\nx=int(input(\"Enter Number of Terms :\"))\nfirst=0\nsec=1\nc=0\nif(x<0):\n    print(\"Enter valid input..\")\nelif(x==0):\n    print(0)\nelif(x==1):",
        "detail": "def.Assignment 1.Fibbo-iterative",
        "documentation": {}
    },
    {
        "label": "recur_fibo",
        "kind": 2,
        "importPath": "def.Assignment 1.Fibo-Recursive",
        "description": "def.Assignment 1.Fibo-Recursive",
        "peekOfCode": "def recur_fibo(n):  \n   global COUNT\n   COUNT=COUNT+1\n   if n <= 1:  \n       return n  \n   else:  \n       return(recur_fibo(n-1) + recur_fibo(n-2))  \n# take input from the user  \nnterms = int(input(\"How many terms? \"))  \n# check if the number of terms is valid  ",
        "detail": "def.Assignment 1.Fibo-Recursive",
        "documentation": {}
    },
    {
        "label": "nterms",
        "kind": 5,
        "importPath": "def.Assignment 1.Fibo-Recursive",
        "description": "def.Assignment 1.Fibo-Recursive",
        "peekOfCode": "nterms = int(input(\"How many terms? \"))  \n# check if the number of terms is valid  \nif nterms <= 0:  \n   print(\"Plese enter a positive integer\")  \nelse:  \n   print(\"Fibonacci sequence:\")  \n   for i in range(nterms):  \n       print(recur_fibo(i))\nprint(\"Steps reqired using Counter \", COUNT)",
        "detail": "def.Assignment 1.Fibo-Recursive",
        "documentation": {}
    },
    {
        "label": "node",
        "kind": 6,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "class node: \n\tdef __init__(self, freq, symbol, left=None, right=None): \n\t\tself.freq = freq \n\t\tself.symbol = symbol \n\t\tself.left = left \n\t\tself.right = right \n\t\tself.huff = '' \n\tdef __lt__(self, nxt): \n\t\treturn self.freq < nxt.freq \ndef printNodes(node, val=''): ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "printNodes",
        "kind": 2,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "def printNodes(node, val=''): \n\tnewVal = val + str(node.huff) \n\tif(node.left): \n\t\tprintNodes(node.left, newVal) \n\tif(node.right): \n\t\tprintNodes(node.right, newVal) \n\tif(not node.left and not node.right): \n\t\tprint(f\"{node.symbol} -> {newVal}\") \nchars = ['a', 'b', 'c', 'd', 'e', 'f'] \nfreq = [5, 9, 12, 13, 16, 45] ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\t\tself.freq",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\t\tself.freq = freq \n\t\tself.symbol = symbol \n\t\tself.left = left \n\t\tself.right = right \n\t\tself.huff = '' \n\tdef __lt__(self, nxt): \n\t\treturn self.freq < nxt.freq \ndef printNodes(node, val=''): \n\tnewVal = val + str(node.huff) \n\tif(node.left): ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\t\tself.symbol",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\t\tself.symbol = symbol \n\t\tself.left = left \n\t\tself.right = right \n\t\tself.huff = '' \n\tdef __lt__(self, nxt): \n\t\treturn self.freq < nxt.freq \ndef printNodes(node, val=''): \n\tnewVal = val + str(node.huff) \n\tif(node.left): \n\t\tprintNodes(node.left, newVal) ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\t\tself.left",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\t\tself.left = left \n\t\tself.right = right \n\t\tself.huff = '' \n\tdef __lt__(self, nxt): \n\t\treturn self.freq < nxt.freq \ndef printNodes(node, val=''): \n\tnewVal = val + str(node.huff) \n\tif(node.left): \n\t\tprintNodes(node.left, newVal) \n\tif(node.right): ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\t\tself.right",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\t\tself.right = right \n\t\tself.huff = '' \n\tdef __lt__(self, nxt): \n\t\treturn self.freq < nxt.freq \ndef printNodes(node, val=''): \n\tnewVal = val + str(node.huff) \n\tif(node.left): \n\t\tprintNodes(node.left, newVal) \n\tif(node.right): \n\t\tprintNodes(node.right, newVal) ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\t\tself.huff",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\t\tself.huff = '' \n\tdef __lt__(self, nxt): \n\t\treturn self.freq < nxt.freq \ndef printNodes(node, val=''): \n\tnewVal = val + str(node.huff) \n\tif(node.left): \n\t\tprintNodes(node.left, newVal) \n\tif(node.right): \n\t\tprintNodes(node.right, newVal) \n\tif(not node.left and not node.right): ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\tnewVal",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\tnewVal = val + str(node.huff) \n\tif(node.left): \n\t\tprintNodes(node.left, newVal) \n\tif(node.right): \n\t\tprintNodes(node.right, newVal) \n\tif(not node.left and not node.right): \n\t\tprint(f\"{node.symbol} -> {newVal}\") \nchars = ['a', 'b', 'c', 'd', 'e', 'f'] \nfreq = [5, 9, 12, 13, 16, 45] \nnodes = [] ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "chars",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "chars = ['a', 'b', 'c', 'd', 'e', 'f'] \nfreq = [5, 9, 12, 13, 16, 45] \nnodes = [] \nfor x in range(len(chars)): \n\theapq.heappush(nodes, node(freq[x], chars[x])) \nwhile len(nodes) > 1: \n\tleft = heapq.heappop(nodes) \n\tright = heapq.heappop(nodes) \n\tleft.huff = 0\n\tright.huff = 1",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "freq",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "freq = [5, 9, 12, 13, 16, 45] \nnodes = [] \nfor x in range(len(chars)): \n\theapq.heappush(nodes, node(freq[x], chars[x])) \nwhile len(nodes) > 1: \n\tleft = heapq.heappop(nodes) \n\tright = heapq.heappop(nodes) \n\tleft.huff = 0\n\tright.huff = 1\n\tnewNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right) ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "nodes",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "nodes = [] \nfor x in range(len(chars)): \n\theapq.heappush(nodes, node(freq[x], chars[x])) \nwhile len(nodes) > 1: \n\tleft = heapq.heappop(nodes) \n\tright = heapq.heappop(nodes) \n\tleft.huff = 0\n\tright.huff = 1\n\tnewNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right) \n\theapq.heappush(nodes, newNode) ",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\tleft",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\tleft = heapq.heappop(nodes) \n\tright = heapq.heappop(nodes) \n\tleft.huff = 0\n\tright.huff = 1\n\tnewNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right) \n\theapq.heappush(nodes, newNode) \nprintNodes(nodes[0])",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\tright",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\tright = heapq.heappop(nodes) \n\tleft.huff = 0\n\tright.huff = 1\n\tnewNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right) \n\theapq.heappush(nodes, newNode) \nprintNodes(nodes[0])",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\tleft.huff",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\tleft.huff = 0\n\tright.huff = 1\n\tnewNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right) \n\theapq.heappush(nodes, newNode) \nprintNodes(nodes[0])",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\tright.huff",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\tright.huff = 1\n\tnewNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right) \n\theapq.heappush(nodes, newNode) \nprintNodes(nodes[0])",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "\tnewNode",
        "kind": 5,
        "importPath": "def.Assignment 2.Assignement_2",
        "description": "def.Assignment 2.Assignement_2",
        "peekOfCode": "\tnewNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right) \n\theapq.heappush(nodes, newNode) \nprintNodes(nodes[0])",
        "detail": "def.Assignment 2.Assignement_2",
        "documentation": {}
    },
    {
        "label": "fib_iterative",
        "kind": 2,
        "importPath": "mod.A1",
        "description": "mod.A1",
        "peekOfCode": "def fib_iterative(n):\n    step_count = 0 \n    series = [0, 1]\n    if n <= 0:\n        return \"Please enter a positive integer.\", step_count\n    elif n == 1:\n        step_count += 1  \n        return [0], step_count\n    elif n == 2:\n        step_count += 1 ",
        "detail": "mod.A1",
        "documentation": {}
    },
    {
        "label": "fib_recursive_series",
        "kind": 2,
        "importPath": "mod.A1",
        "description": "mod.A1",
        "peekOfCode": "def fib_recursive_series(n, series=None, step_count=0):\n    if n <= 0:\n        return \"Please enter a positive integer.\", step_count\n    elif n == 1:\n        step_count += 1 \n        return [0], step_count\n    elif n == 2:\n        step_count += 1  \n        return [0, 1], step_count\n    if series is None:",
        "detail": "mod.A1",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "mod.A1",
        "description": "mod.A1",
        "peekOfCode": "def main():\n    while True:\n        print(\"\\n Menu:\")\n        print(\"1. Fibonacci Series using Iterative approach\")\n        print(\"2. Fibonacci Series using Recursive approach\")\n        print(\"3. Exit\")\n        choice = int(input(\"Choose an option : \"))\n        if choice == 1 or choice == 2:\n            n = int(input(\"Enter the number of terms (n): \"))\n            if choice == 1:",
        "detail": "mod.A1",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "mod.A2",
        "description": "mod.A2",
        "peekOfCode": "class Node:\n    def __init__(self, freq, symbol, left=None, right=None):\n        self.freq = freq\n        self.symbol = symbol\n        self.left = left\n        self.right = right\n        self.huff = ''\n    def __lt__(self, nxt):\n        return self.freq < nxt.freq\ndef printNodes(node, val=''):",
        "detail": "mod.A2",
        "documentation": {}
    },
    {
        "label": "printNodes",
        "kind": 2,
        "importPath": "mod.A2",
        "description": "mod.A2",
        "peekOfCode": "def printNodes(node, val=''):\n    newVal = val + str(node.huff)\n    if node.left:\n        printNodes(node.left, newVal)\n    if node.right:\n        printNodes(node.right, newVal)\n    if not node.left and not node.right:\n        print(f\"{node.symbol} -> {newVal}\")\ndef huffman_encoding(chars, freq):\n    nodes = []",
        "detail": "mod.A2",
        "documentation": {}
    },
    {
        "label": "huffman_encoding",
        "kind": 2,
        "importPath": "mod.A2",
        "description": "mod.A2",
        "peekOfCode": "def huffman_encoding(chars, freq):\n    nodes = []\n    for x in range(len(chars)):\n        heapq.heappush(nodes, Node(freq[x], chars[x]))\n    while len(nodes) > 1:\n        left = heapq.heappop(nodes)\n        right = heapq.heappop(nodes)\n        left.huff = 0\n        right.huff = 1\n        newNode = Node(left.freq + right.freq, left.symbol + right.symbol, left, right)",
        "detail": "mod.A2",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "mod.A2",
        "description": "mod.A2",
        "peekOfCode": "def main():\n    num = int(input(\"Enter the number of characters: \"))\n    chars = []\n    freq = []\n    for i in range(num):\n        char = input(f\"Enter character {i+1}: \")\n        frequency = int(input(f\"Enter frequency of '{char}': \"))\n        chars.append(char)\n        freq.append(frequency)\n    huffman_encoding(chars, freq)",
        "detail": "mod.A2",
        "documentation": {}
    },
    {
        "label": "knapsack_dp",
        "kind": 2,
        "importPath": "mod.A3",
        "description": "mod.A3",
        "peekOfCode": "def knapsack_dp(weights, values, capacity):\n    n = len(values)\n    dp = [[0 for w in range(capacity + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i - 1] <= w:\n                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])\n            else:\n                dp[i][w] = dp[i - 1][w]\n    return dp, dp[n][capacity]",
        "detail": "mod.A3",
        "documentation": {}
    },
    {
        "label": "print_selected_items",
        "kind": 2,
        "importPath": "mod.A3",
        "description": "mod.A3",
        "peekOfCode": "def print_selected_items(dp, weights, values, capacity):\n    n = len(values)\n    w = capacity\n    selected_items = []\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i - 1][w]:\n            selected_items.append(i - 1)\n            w -= weights[i - 1]\n    print(f\"Selected item indices: {selected_items[::-1]}\")\n    return selected_items",
        "detail": "mod.A3",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "mod.A3",
        "description": "mod.A3",
        "peekOfCode": "def main():\n    n = int(input(\"Enter number of items: \"))\n    weights = []\n    values = []\n    for i in range(n):\n        weight = int(input(f\"Enter weight of item {i+1}: \"))\n        value = int(input(f\"Enter value of item {i+1}: \"))\n        weights.append(weight)\n        values.append(value)\n    capacity = int(input(\"Enter capacity of knapsack: \"))",
        "detail": "mod.A3",
        "documentation": {}
    },
    {
        "label": "QueenChessBoard",
        "kind": 6,
        "importPath": "mod.A4",
        "description": "mod.A4",
        "peekOfCode": "class QueenChessBoard:\n    def __init__(self, size):\n        self.size = size\n        self.columns = []\n    def place_in_next_row(self, column):\n        self.columns.append(column)\n    def remove_in_current_row(self):\n        return self.columns.pop()\n    def is_this_column_safe_in_next_row(self, column):\n        row = len(self.columns)",
        "detail": "mod.A4",
        "documentation": {}
    },
    {
        "label": "solve_queen",
        "kind": 2,
        "importPath": "mod.A4",
        "description": "mod.A4",
        "peekOfCode": "def solve_queen(size):\n    board = QueenChessBoard(size)\n    number_of_solutions = 0\n    row = 0\n    column = 0\n    while True:\n        while column < size:\n            if board.is_this_column_safe_in_next_row(column):\n                board.place_in_next_row(column)\n                row += 1",
        "detail": "mod.A4",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "mod.A4",
        "description": "mod.A4",
        "peekOfCode": "n = int(input('Enter n: '))\nsolve_queen(n)",
        "detail": "mod.A4",
        "documentation": {}
    },
    {
        "label": "partition_deterministic",
        "kind": 2,
        "importPath": "mod.A5",
        "description": "mod.A5",
        "peekOfCode": "def partition_deterministic(arr, low, high):\n    pivot = arr[high] \n    i = low - 1  \n    swap_count = 0  \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i] \n            swap_count += 1\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]  ",
        "detail": "mod.A5",
        "documentation": {}
    },
    {
        "label": "quicksort_deterministic",
        "kind": 2,
        "importPath": "mod.A5",
        "description": "mod.A5",
        "peekOfCode": "def quicksort_deterministic(arr, low, high):\n    swap_count = 0\n    if low < high:\n        pi, swaps = partition_deterministic(arr, low, high)\n        swap_count += swaps\n        swap_count += quicksort_deterministic(arr, low, pi - 1)\n        swap_count += quicksort_deterministic(arr, pi + 1, high)\n    return swap_count\ndef partition_randomized(arr, low, high):\n    pivot_index = random.randint(low, high) ",
        "detail": "mod.A5",
        "documentation": {}
    },
    {
        "label": "partition_randomized",
        "kind": 2,
        "importPath": "mod.A5",
        "description": "mod.A5",
        "peekOfCode": "def partition_randomized(arr, low, high):\n    pivot_index = random.randint(low, high) \n    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]  \n    return partition_deterministic(arr, low, high)  \ndef quicksort_randomized(arr, low, high):\n    swap_count = 0\n    if low < high:\n        pi, swaps = partition_randomized(arr, low, high)\n        swap_count += swaps\n        swap_count += quicksort_randomized(arr, low, pi - 1)",
        "detail": "mod.A5",
        "documentation": {}
    },
    {
        "label": "quicksort_randomized",
        "kind": 2,
        "importPath": "mod.A5",
        "description": "mod.A5",
        "peekOfCode": "def quicksort_randomized(arr, low, high):\n    swap_count = 0\n    if low < high:\n        pi, swaps = partition_randomized(arr, low, high)\n        swap_count += swaps\n        swap_count += quicksort_randomized(arr, low, pi - 1)\n        swap_count += quicksort_randomized(arr, pi + 1, high)\n    return swap_count\ndef main():\n    n = int(input(\"Enter the number of elements in the array: \"))",
        "detail": "mod.A5",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "mod.A5",
        "description": "mod.A5",
        "peekOfCode": "def main():\n    n = int(input(\"Enter the number of elements in the array: \"))\n    arr = [random.randint(0, 1000) for _ in range(n)] \n    arr_deterministic = arr.copy()\n    arr_randomized = arr.copy()\n    print(\"\\nDeterministic QuickSort:\")\n    start_time = time.time()\n    swaps_deterministic = quicksort_deterministic(arr_deterministic, 0, n - 1)\n    end_time = time.time()\n    print(f\"Sorted Array: {arr_deterministic}\")",
        "detail": "mod.A5",
        "documentation": {}
    },
    {
        "label": "fib_iterative",
        "kind": 2,
        "importPath": "prac.A1C",
        "description": "prac.A1C",
        "peekOfCode": "def fib_iterative(n):\n    sc = 0\n    series = [0,1]\n    if n<=0:\n        return \"Please Enter valid input.\", sc\n    elif n==1:\n        sc += 1\n        return [0], sc\n    elif n==2:\n        sc += 1",
        "detail": "prac.A1C",
        "documentation": {}
    },
    {
        "label": "fib_recursive",
        "kind": 2,
        "importPath": "prac.A1C",
        "description": "prac.A1C",
        "peekOfCode": "def fib_recursive(n, series=None, sc=0):\n    if n<=0:\n        return \"Please Enter the valid input.\", sc\n    elif n==1:\n        sc += 1\n        return [0], sc\n    elif n==2:\n        sc += 1\n        return [0, 1], sc\n    if series == None:",
        "detail": "prac.A1C",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "prac.A1C",
        "description": "prac.A1C",
        "peekOfCode": "def main():\n    while(True):\n        print(\"1. Fibonacci series using iterative approach.\")\n        print(\"2. Fibonacci series using recursive approach.\")\n        print(\"3. Exit\")\n        ch = int(input(\"Choose an option : \"))\n        if ch==1:\n            in1 = int(input(\"Enter the number of elements : \"))\n            series, sc = fib_iterative(in1)\n            print(f\"Fibonacci series : {series}\")",
        "detail": "prac.A1C",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "prac.A2C",
        "description": "prac.A2C",
        "peekOfCode": "class Node:\n    def __init__(self, symbol, freq, left=None, right=None):\n        self.symbol = symbol\n        self.freq = freq\n        self.left = left\n        self.right = right\n        self.huff = \"\"\n    def __lt__(self, next):\n        return self.freq < next.freq\ndef printNodes(node, val=\"\"):",
        "detail": "prac.A2C",
        "documentation": {}
    },
    {
        "label": "printNodes",
        "kind": 2,
        "importPath": "prac.A2C",
        "description": "prac.A2C",
        "peekOfCode": "def printNodes(node, val=\"\"):\n    newVal = val+str(node.huff)\n    if node.left:\n        printNodes(node.left, newVal)\n    if node.right:\n        printNodes(node.right, newVal)\n    if not node.left and not node.right:\n        print(f\"{node.symbol} ->  {newVal}\")\ndef huffman_enc(symbols, freq):\n    nodes = []",
        "detail": "prac.A2C",
        "documentation": {}
    },
    {
        "label": "huffman_enc",
        "kind": 2,
        "importPath": "prac.A2C",
        "description": "prac.A2C",
        "peekOfCode": "def huffman_enc(symbols, freq):\n    nodes = []\n    for i in range(len(symbols)):\n        heapq.heappush(nodes, Node(symbols[i], freq[i]))\n    while len(nodes)>1:\n        left = heapq.heappop(nodes)\n        right = heapq.heappop(nodes)\n        left.huff = 0\n        right.huff = 1\n        newNode = Node(left.symbol+right.symbol, left.freq+right.freq, left, right)",
        "detail": "prac.A2C",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "prac.A2C",
        "description": "prac.A2C",
        "peekOfCode": "def main():\n    # symbols = []\n    # freq = []\n    # n = int(input(\"Enter no. of characters : \"))\n    # for i in range(n):\n    #     s = input(\"Enter the Character : \")\n    #     f = int(input(\"Enter the frequency : \"))\n    #     symbols.append(s)\n    #     freq.append(f)\n    symbols = ['a', 'b', 'c', 'd', 'e', 'f'] ",
        "detail": "prac.A2C",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "prac.A2C1",
        "description": "prac.A2C1",
        "peekOfCode": "class Node:\n    def __init__(self, symbol, freq, left=None, right=None):\n        self.symbol = symbol\n        self.freq = freq\n        self.left = left\n        self.right = right\n        self.huff = \"\"\n    def __lt__(self, next):\n        return self.freq < next.freq\ndef printNodes(node, val=\"\"):",
        "detail": "prac.A2C1",
        "documentation": {}
    },
    {
        "label": "printNodes",
        "kind": 2,
        "importPath": "prac.A2C1",
        "description": "prac.A2C1",
        "peekOfCode": "def printNodes(node, val=\"\"):\n    newVal = val+str(node.huff)\n    if node.left:\n        printNodes(node.left, newVal)\n    if node.right:\n        printNodes(node.right, newVal)\n    if not node.left and not node.right:\n        print(f\"{node.symbol} -> {newVal}\")\ndef huff_enc(symbols, freq):\n    nodes = []",
        "detail": "prac.A2C1",
        "documentation": {}
    },
    {
        "label": "huff_enc",
        "kind": 2,
        "importPath": "prac.A2C1",
        "description": "prac.A2C1",
        "peekOfCode": "def huff_enc(symbols, freq):\n    nodes = []\n    for i in range(len(symbols)):\n        heapq.heappush(nodes, Node(symbols[i], freq[i]))\n    while len(nodes)>1:\n        left = heapq.heappop(nodes)\n        right = heapq.heappop(nodes)\n        left.huff = 0\n        right.huff = 1\n        newNode = Node(left.symbol+right.symbol, left.freq+right.freq, left, right)",
        "detail": "prac.A2C1",
        "documentation": {}
    },
    {
        "label": "symbols",
        "kind": 5,
        "importPath": "prac.A2C1",
        "description": "prac.A2C1",
        "peekOfCode": "symbols = ['a', 'b', 'c', 'd', 'e', 'f'] \nfreq = [5, 9, 12, 13, 16, 45] \nhuff_enc(symbols, freq)",
        "detail": "prac.A2C1",
        "documentation": {}
    },
    {
        "label": "freq",
        "kind": 5,
        "importPath": "prac.A2C1",
        "description": "prac.A2C1",
        "peekOfCode": "freq = [5, 9, 12, 13, 16, 45] \nhuff_enc(symbols, freq)",
        "detail": "prac.A2C1",
        "documentation": {}
    }
]